# -*- coding: utf-8 -*-
"""Copy of Day3_Pandas.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/15A5QczPKCHQ89Zw3e3ULMTCAhdKYfQQq
"""

#mount google drive

from google.colab import drive
drive.mount('/content/drive')

"""Use the following code to upload the file from your local machine:

```
from google.colab import files
uploaded = files.upload()
```

After uploading, read the file into a Pandas DataFrame:

```
import pandas as pd

dataframe = pd.read_csv('student.csv')

dataframe```

"""

#import pandas
import pandas as pd

import pandas as pd

# Replace with the actual path to your file
file_path = '/content/drive/MyDrive/JustIT_Python/pandas/Resources/Copy of student.csv'
df = pd.read_csv(file_path)
print(df)

"""#Inspecting Data

Lets try and see what methods are available to us to inspect datasets
"""

#head() by default shows the top five rows of the dataset
print(df.head())

df.head(5)

#you can view amount of rows if you insert number into brackets
df.head(10)

#if there is a head there is a tail
#by default it shows the last five rows
df.tail()

#checking for basic information using info()
df.info()

# inspecting summary statistics
print(df.describe())

df.describe()

#checking for missing values one by one
df.isnull()

#checking for missing values
df.isnull().sum()

#checking for summary of the missing values
df.isnull().sum().sum()

#inspecting the rows v column
df.shape

#checking for unique values in a column
df['gender'].unique()

#finding duplicates in the data
df.duplicated().sum() #this checks for duplicated rows

#sorting for the top marks achieved by students
df.sort_values(by='mark', ascending=False) #by default its ascending (which is when its not included)
#descending does not exist so it is written ascending=False

#sorting for the top 10 students by mark
df.sort_values(by='mark', ascending=False).head(10)

#sorting by multiple columns with different ordering
df.sort_values(by=['mark', 'id'], ascending=[False, True])

#selecting columns
df['name']

df.head()

"""#Locating data .iloc() and .loc()

.loc is label based way of retreiving data from the dataframe

.iloc is interger based way of retreiving data from the dataframe

#Locating data `.iloc[]` and `.loc[]`

# **Lesson Plan: Understanding `.loc` and `.iloc` in Pandas**
### **Course:** Data Technician ‚Äì Python for Data Analysis  
### **Day:** 3  
### **Duration:** 1 Hour  
### **Teaching Style:** Hands-on with explanations and real dataset usage  

---

## **Lesson Objectives**
By the end of this lesson, learners will be able to:
1. Understand the difference between `.loc` and `.iloc`.
2. Retrieve specific rows and columns using `.loc` and `.iloc`.
3. Apply filtering techniques to extract meaningful data.
4. Practice `.loc` and `.iloc` using the **Student Dataset**.

---

## **1. Introduction: What are `.loc` and `.iloc`?**
When working with large datasets in Pandas, we often need to **select specific rows and columns**.  
This can be done using:
1. **`.loc[]`** ‚Üí Selects data **by label (name of the row or column)**.
2. **`.iloc[]`** ‚Üí Selects data **by position (row or column index number)**.

Think of it as:
- **`.loc`** ‚Üí Uses **explicit labels** (like column names or row labels).
- **`.iloc`** ‚Üí Uses **integer-based indexing** (position numbers).

---

## **2. Key Differences Between `.loc` and `.iloc`**
| Feature  | `.loc[]`  | `.iloc[]`  |
|----------|----------|-----------|
| **Selection Type** | Label-based (row/column name) | Position-based (row/column index) |
| **Index Type** | Works with **row names/column names** | Works with **integer index** |
| **Inclusive Range?** | Yes, includes both start and end index | No, excludes the last index |
| **Example (Row 1 to 3)** | `df.loc[1:3]` ‚Üí Includes row **3** | `df.iloc[1:3]` ‚Üí Excludes row **3** |
| **Selecting Single Row** | `df.loc[2]` ‚Üí Selects row **2** | `df.iloc[2]` ‚Üí Selects row **2** |
| **Selecting Single Column** | `df.loc[:, 'mark']` | `df.iloc[:, 2]` (if 'mark' is column 2) |
| **Filtering with Conditions?** | Yes ‚úÖ | No ‚ùå |

---
"""

row_data =df.loc[2]
print(row_data)

subset_data =df.iloc[0:2, 0:2]
print(subset_data)

#using .loc i want to access row 10
df.loc[10]

#selecting multiple rows
df.loc[[0,1,2,3]]

#selecting multiple rows from a range
df.loc[3:8] #in label based, the row 8 will be included

#accessing a specific column
df.loc[:, "gender"]

#accessing multiple columns
df.loc[:, ['name', 'mark']]

#accessing rows and columns
df.loc[[1,2,3], ['gender', 'mark']]

#accessing rows and columns using range for rows
df.loc[0:3, ['gender', 'mark']]

#filtering data with conditions
df.loc[df['mark'] > 80].head()

#filtering data with multiple conditions
#showing marks from class seven for females only
df.loc[(df['gender'] == 'female') & (df['class'] == 'Seven')]

df.loc[(df["class"] == "Four")]

#select specific columns
df[['name', 'mark']]

# add a new column based on condition
df["passed"] = df["mark"] >= 60
df.head()

#add a new column with filled info
df["new"] = "stuff"
df.head()

# rename column
df = df.rename(columns={"mark" : "score"})
df.head()

# IGNORE to revert column back to original
df = df.rename(columns={"score" : "mark"})
df.head()

# dropping column - removing a column
df = df.drop(columns=["passed"])
df.head()
#once it is run it can't be repeated since the column has been dropped and does not exist to run again

# dropping columns - removing multiple columns
df = df.drop(columns=["new", "new2"])
df.head()
#once it is run it can't be repeated since the columns have been dropped and does not exist to run again

#group df by "class" and calculating the mean "mark" for each group
df.groupby("class")["mark"].mean()

# count of students in each class
df["class"].value_counts()

# average "mark" for each "gender"
df.groupby("gender")["mark"].mean()

"""#Integer based selection

Using .iloc
"""

#accessing single row by index position
df.iloc[3]

#selecting a range of rows
df.iloc[2:5] #exclusive of row 5

#selecting a column using .iloc
df.iloc[:, 2]

#selecting range of columns and rows
df.iloc[2:5, 1:3]

#do you think negative indexing will work on .iloc?
#using negative indexing to retrieve the data
df.iloc[-1, -1]

"""###Student Activity Questions


1. use loc to slect row where marks are greater than 85
2. use iloc to select  the first 10 rows
3. use .loc to select name and mark column for al students
4. use .iloc to selelct teh first three columns


"""

#use .loc to select row where marks are greater than 85
df.loc[df["mark"] > 85]

#use .iloc to select the first 10 rows
df.iloc[0:10]

#use .loc to select name and mark column for all students
df.loc[:,["name", "mark"]]

#use .iloc to select the first three columns
df.iloc[:,0:3].head()



"""---

## **Hands-On Activity: Extracting Data from the Student Dataset**
### **Task 1: Extract Specific Rows**
1. Use `.loc[]` to **select rows where the mark is greater than 85**.
2. Use `.iloc[]` to **select the first 10 rows**.

üìå **Expected Code, Task 1:**
```python
# Using .loc
df.loc[df['mark'] > 85]

# Using .iloc
df.iloc[:10]
```
---

### **Task 2: Select Specific Columns**
1. Use `.loc[]` to **select "name" and "mark" columns** for all students.
2. Use `.iloc[]` to **select the first 3 columns**.

üìå **Expected Code, Task 2:**
```python
# Using .loc
df.loc[:, ['name', 'mark']]

# Using .iloc
df.iloc[:, :3]
```
---

### **Task 3: Filtering Based on Conditions**
1. Select **all female students who scored more than 75** using `.loc[]`.
2. Find students from index **10 to 20** and select only `name` and `mark` using `.iloc[]`.

üìå **Expected Code, Task 3:**
```python
# Using .loc
df.loc[(df['gender'] == 'female') & (df['mark'] > 75)]

# Using .iloc
df.iloc[10:21, [1, 3]]  # 1st and 3rd column (name and mark)
```
---

### **Bonus Task: Sorting & Filtering**
- **Find top 5 students based on marks** using `.loc[]` and `sort_values()`.
- **Find students from the last 5 rows** using `.iloc[]`.

üìå **Expected Code, Bonus Task:**
```python
# Top 5 students using .loc and sorting
df.loc[:, ['name', 'mark']].sort_values(by='mark', ascending=False).head(5)

# Last 5 students using .iloc
df.iloc[-5:]
```
---

## **6. Summary**
| Feature  | `.loc[]`  | `.iloc[]`  |
|----------|----------|-----------|
| **Selection Type** | Label-based (column/row names) | Index-based (position numbers) |
| **Includes Last Index?** | Yes ‚úÖ | No ‚ùå |
| **Supports Filtering?** | Yes ‚úÖ | No ‚ùå |
| **Best For?** | Named columns/rows | Numerical indexing |

---

## **7. Assessment & Discussion**
‚úÖ **Quiz Questions**
1. How do you select only the **name** and **mark** columns using `.loc[]`?
2. How do you select the **first 5 rows** using `.iloc[]`?
3. What is the difference between `.loc[]` and `.iloc[]`?
4. How do you select all students with marks **greater than 80** using `.loc[]`?
5. How do you use `.iloc[]` to get the **last 3 rows**?

‚úÖ **Discussion**
- When should you use `.loc[]` instead of `.iloc[]`?
- Why does `.iloc[]` **exclude** the last index?

---

## **8. Further Learning**
- **Pandas Documentation** ‚Üí [Pandas .loc and .iloc](https://pandas.pydata.org/docs/user_guide/indexing.html)
- **Interactive Pandas Exercise** ‚Üí [Kaggle Pandas Course](https://www.kaggle.com/learn/pandas)
- **Python for Data Analysis Book** ‚Üí [O'Reilly Pandas Guide](https://www.oreilly.com/library/view/python-for-data/9781491957653/)

---
"""

df.isnull().sum()

#filling missing values in gender column with "not specified"
df["gender"].fillna("not specified", inplace=True)
df

#replacing missing values in "mark" column with mean of all the values in the "mark" column
#one step method
#two step method

#fill missing values
df["class"].fillna("Unknown", inplace=True)
df

#removing duplicates
df.drop_duplicates(inplace=True)
df

#inconsistent data
df['class'] = df['class'].str.upper()
df

#inconsistent data replacing typos
df['gender'] = df['gender'].replace({'Malee': "Male", 'Femalee':'Female'})
df

#inconsistent data replacing data type
df['mark'] = pd.to_numeric(df['mark'], errors='coerce')
df

"""#Visualisations"""

pip install matplotlib seaborn

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

plt.figure(figsize=(10, 6))
plt.hist(df["mark"], bins=10, edgecolor="black")
plt.title("Distribution of Marks")
plt.xlabel("Marks")
plt.ylabel("Frequency")
plt.show()